::::::::::::::::::::DISTRIBUTED ARCH DESCRIPTION::::::::::::::::::::

* local ip: is self explanatory (the distributor needs this to pass this address to the remote machine, so the remote machine can connect back to the local machine in case the function call has object references).

* local port: is the first port used by the local machine to create reverse proxies that represents object references. 

* |localip:localport, remoteip:remoteport, remoteip:remoteport|complist|comprelations|

NOTE: This only works if you relocate/replicate one interface at a time (if it is multiple than it won't work -- we would need to expand it to know the list of ips for the different relocated interfaces + the portManager has to coordinate the ports better). I have to bear this in mind for the real version of the relocate framework.

::::::::::::::::::::PORTS IN THE DISTRIBUTED SYSTEM::::::::::::::::::::

2013 - is the port for the root component HTTPGETREMOTE (the one that runs on remote machines)
2014 - is the first port used to create proxies (the servers on the client side --- i.e. the ones that represents the original reference passed on to the remote machine), the proxies are going to be used from 2014 onwards.
NOTE THAT: on the server side (i.e. the machine where we relocated components) only has the root component bound to a port, it does not have to create server proxies to be bound in any port. Unless the machine decides to relocate components itself. Then it'll have to use ports to bind the proxies that will represent the original object reference. In this last case scenario I won't be able to experiment everything locally.

::::::::::::::::::::REDIR::::::::::::::::::::

redir --lport=3306 --laddr=scc-mc10.lancs.ac.uk --cport=3306 --caddr=localhost

::::::::::::::::::::PEL Queries that was tested!::::::::::::::::::::

1)
add_proxy |../metacom/monitoring/proxies/HTTPProxy.o|*(*:HTTPHandler[0]:*)|

2)
add_proxy |../metacom/monitoring/proxies/HTTPProxy.o|1(*:HTTPHandler[0]:*)|

3)
add_proxy |../web_server/http/HTTPProtocol.o,../metacom/monitoring/proxies/HTTPProxy.o|1(0:HTTPHandler[1]:*)|

4)
add_proxy |../web_server/request/RequestHandler.o,../web_server/http/HTTPProtocol.o,../metacom/monitoring/proxies/HTTPProxy.o|1(0:HTTPProtocol:1,1:HTTPHandler[2]:*)|

5)
add_proxy |../web_server/request/RequestHandlerPT.o,../web_server/http/HTTPProtocol.o,../metacom/monitoring/proxies/HTTPProxy.o|*(0:HTTPProtocol:1,1:HTTPHandler[2]:*)|

6)
add_proxy |../metacom/monitoring/proxies/LBProxy.o|*(*:LBHandler[0]:*)|

7)
add_proxy |../metacom/monitoring/proxies/HTTPProxy.o|*(*:http.handler.GET.HTTPGET[0]:*)|
add_proxy |../pal/monitoring/proxies/HTTPProxy.o|*(*:http.handler.GET.HTTPGET[0]:*)|

add_proxy |../pal/monitoring/proxies/NeuralNetProxy.o|*(*:OutputLayer[0]:*)|



8)
add_proxy |../metacom/monitoring/proxies/MetricProxy.o|*(*:HTTPHeader[0]:*)|

9)
add_proxy |../metacom/monitoring/proxies/CacheProxy.o|*(*:CacheHandler[0]:*)|

The following query does not work in this current version, but might in the future.
1)
add_proxy |../web_server/request/RequestHandlerPT.o,../metacom/monitoring/proxies/HTTPProxy.o|1(0:HTTPProtocol:*,*:HTTPHandler[1]:*)|
-> the reason why this doesn't work is because there is * in the binding exp that is not the last one. The idea behind this is that you would add a path/an exact string with all the exact bindings that comes before the binding exp where the proxy should be placed at. 

::::::::::::::::::::Queries to be tested!::::::::::::::::::::

-> make some exp with &
-> make some exp with ;
-> makes ome exp with & and ;
